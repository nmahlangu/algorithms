# Divide two integers without using multiplication, division and mod operator.
# If it is overflow, return MAX_INT

class Solution(object):
    def __init__(self):
        self.MAX_INT = (2**31)-1
        self.MIN_INT = -(2**31)

    def divide(self, dividend, divisor):
        if (divisor == 0) or (dividend == self.MIN_INT and divisor == -1):
            return self.MAX_INT

        positive = True if (dividend > 0 and divisor > 0) or (dividend < 0 and divisor < 0) else False
        dividend = abs(dividend)
        divisor = abs(divisor)
        
        result = 0
        while dividend >= divisor:
            l_shifts = 0
            while dividend >= (divisor << l_shifts):
                l_shifts += 1
            result += 1 << (l_shifts - 1)
            dividend -= divisor << (l_shifts - 1)
        return result if positive else -result        
    
# The naive way of doing this is to repeatedly subtract the divisor from the divident, while incrementing
# a counter. However, this can be very slow if the dividend is large and the divisor is very small.
# Thus, a better approach is to find the largest multiple of the divisor (that can be generated by multiplying
# the divisor by 2) and subtract that way from the dividend repeatedly until the dividend is less than 
# the divisor. Multiplying by 2 can be simulated by left shifting a number by 1. Time complexity is
# O(logn) and space complexity is O(1)
